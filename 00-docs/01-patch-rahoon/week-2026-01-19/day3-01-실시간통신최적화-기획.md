# 패치노트 - 실시간 통신 최적화 (기획)

## Before

- 메시지 도메인은 **REST API만** 제공 (POST/GET /messages)
- 클라이언트가 새 메시지를 받으려면 **폴링** 또는 **수동 새로고침** 필요
- 실시간 알림·수신 경험 부족, 메시지 서비스 핵심 가치인 **즉시 전달** 미달성
- WebSocket/SSE 등 실시간 채널에 대한 **기술 비교·선택·재연결·성능 측정** 계획 없음

## Goal

1. **실시간 메시지 수신**  
   - 발송 즉시 수신자에게 푸시 (폴링 제거)
2. **기술 선택 근거 마련**  
   - WebSocket vs SSE vs Long Polling 비교 후, 서비스 요구사항에 맞는 방식 선정
3. **연결 안정성**  
   - 연결 관리, 재연결 전략 설계 및 적용
4. **성능 정량화**  
   - latency, throughput 측정으로 목표치 설정 및 모니터링 기반 마련

## Key Decision

(비워둠)

## Impact

(비워둠)

---

## 진행 목표

1. WebSocket 구현 (POC: 연결, 구독/수신 — 송신은 POST /messages 유지)
2. SSE 구현 (POC)
3. Long Polling 구현 (POC)
4. 세 방식 비교
   - 4-1. 리소스: 연결당 CPU/메모리, 동시 연결 한계
   - 4-2. 성능: latency, throughput
   - 4-3. 운영·개발: 재연결, LB, 코드 복잡도
5. (비교 결과 반영) 1개 선정 → 프로덕션용 구현


## 진행

### 1. WebSocket 구현

- **의존성**: `spring-boot-starter-websocket` (STOMP 메시징용)
- **엔드포인트**: `/ws`, SockJS fallback 허용
- **인증**: Handshake 시 `Authorization` 또는 `access_token` 쿼리에서 JWT 검증 → `Principal`에 `userId` 넣기 (기존 `AuthTokenResolver` 재사용)
- **구독(수신)**: `/topic/chat-rooms/{chatRoomId}/messages` — 채팅방별 메시지 스트림 구독
- **송신**: WebSocket 제외. 기존 **POST /messages** 사용. 단, 생성 후 `SimpMessagingTemplate.convertAndSend(/topic/chat-rooms/{id}/messages, message)` 로 구독자에게 브로드캐스트 (MessageController 또는 ApplicationService에서)
- **POC 범위**: 연결·구독(수신)만 (재연결, Heartbeat 등은 4번 비교 이후)

#### 구현 관점 장단점

**장점**
- 양방향 통신 가능 (클라이언트→서버, 서버→클라이언트)
- STOMP 프로토콜로 메시지 라우팅, 구독 패턴이 명확
- SockJS fallback으로 브라우저 호환성 확보
- Redis Pub/Sub 등 메시지 브로커로 서버 간 메시지 동기화 구조가 명확

**단점**
- 설정 복잡도 높음 (WebSocketConfig, MessageBroker, Interceptor 등)
- HTTP 표준이 아니므로 프록시/LB 설정 추가 필요 (Upgrade 헤더 처리)
- STOMP 의존성 추가로 번들 사이즈 증가
- 연결 관리 복잡 (Handshake, Session, Subscription 분리 관리)
- Sticky Session 필수 (수평 확장 시 연결이 특정 서버에 고정)
- 서버 재시작 시 모든 클라이언트 재연결 필요
- Redis 등 추가 인프라 필수 (서버 간 메시지 동기화)

### 2. SSE 구현 ✅

- **엔드포인트**: `GET /sse/chat-rooms/{chatRoomId}/messages`
- **인증**: 기존 `AuthTokenResolver` 재사용 (`Authorization` 헤더)
- **구독(수신)**: 채팅방별 메시지 스트림 구독 (타임아웃: 30분)
- **송신**: WebSocket과 동일. 기존 **POST /messages** 사용, `MessageEvent.Created` 이벤트로 SSE 브로드캐스트
- **구현**:
  - `MessageSseEmitterManager`: 채팅방별 SseEmitter 관리 (추가/제거/전송)
  - `MessageSseController`: SSE 엔드포인트 제공
  - `MessageCreatedSseEventListener`: `MessageEvent.Created` → SSE 브로드캐스트
  - `MessageSseIT`: SSE 통합 테스트
- **POC 범위**: 연결·구독(수신)만 (재연결, Heartbeat 등은 4번 비교 이후)

#### 구현 관점 장단점

**장점**
- 구현 단순 (`SseEmitter` 하나면 완결, 추가 의존성 불필요)
- HTTP 표준 (`text/event-stream`), 프록시/LB 설정 불필요
- 기존 인증 필터 그대로 재사용 (Spring MVC 레이어에서 처리)
- 자동 재연결 지원 (브라우저 EventSource API 내장)
- HTTP 기반이라 일반 LB 전략 사용 가능
- 브라우저 자동 재연결로 서버 장애 시 다른 서버로 자동 전환

**단점**
- 단방향 통신만 가능 (서버→클라이언트)
- 브라우저 연결 수 제한 (HTTP/1.1: 도메인당 6개, HTTP/2는 무제한)
- 타임아웃 관리 필요 (장시간 연결 시 주기적 heartbeat 권장)
- IE 미지원 (polyfill 필요)
- Sticky Session 필요 (수평 확장 시)
- Redis Pub/Sub 등 메시지 브로커 필수 (서버 간 메시지 동기화)

### 3. Long Polling 구현 ✅

- **엔드포인트**: `GET /long-polling/chat-rooms/{chatRoomId}/messages`
- **인증**: 기존 `AuthTokenResolver` 재사용 (`Authorization` 헤더)
- **수신**: 새 메시지가 있을 때까지 대기 (타임아웃: 30초)
  - 새 메시지 생성 시 즉시 응답
  - 타임아웃 시 빈 리스트 `[]` 응답
- **송신**: 기존 **POST /messages** 사용, `MessageEvent.Created` 이벤트로 대기 중인 요청에 응답
- **구현**:
  - `MessageLongPollingManager`: 채팅방별 DeferredResult 관리 (추가/제거/응답)
  - `MessageLongPollingController`: Long Polling 엔드포인트 제공
  - `MessageCreatedLongPollingEventListener`: `MessageEvent.Created` → Long Polling 응답
  - `MessageLongPollingIT`: Long Polling 통합 테스트 (메시지 수신, 타임아웃)
- **POC 범위**: 연결·대기(수신)만 (재연결 전략, Since 파라미터 등은 4번 비교 이후)

#### 구현 관점 장단점

**장점**
- 구현 단순 (`DeferredResult` 하나면 완결, 추가 의존성 불필요)
- HTTP 표준 (일반 GET 요청), 프록시/LB 설정 불필요
- 기존 인증 필터 그대로 재사용 (Spring MVC 레이어에서 처리)
- 브라우저 호환성 최대 (IE 포함 모든 브라우저 지원)
- HTTP 기반이라 일반 LB 전략 사용 가능

**단점**
- 연결 효율 낮음 (요청-응답-재요청 반복, HTTP 오버헤드)
- 지연 시간 높음 (클라이언트가 재요청할 때까지 지연, 평균 RTT/2 추가)
- 서버 리소스 비효율 (대기 중인 스레드 또는 비동기 리소스 점유)
- 타임아웃 관리 복잡 (짧으면 재요청 빈번, 길면 리소스 점유 증가)
- Sticky Session 필요 (수평 확장 시)
- Redis Pub/Sub 등 메시지 브로커 필수 (서버 간 메시지 동기화)

### 4. 세 방식 비교

가장 먼저, 구현 전 알고 있는 내용을 바탕으로 1차 정리해본 뒤

아래 지표를 통해 성능을 측정해볼 예정입니다.
1. Latency 측정
2. 동시 연결 부하 테스트
3. 장시간 연결 안정성 테스트

#### 4-1. 알고있는 내용을 바탕으로 1차 정리

| 항목 | WebSocket | SSE | Long Polling |
|------|-----------|-----|--------------|
| 구현 난이도 | 높음 (STOMP 설정) | 낮음 (SseEmitter) | 낮음 (DeferredResult) |
| 통신 방향 | 양방향 | 단방향 | 단방향 |
| 브라우저 지원 | 넓음 (SockJS fallback) | 중간 (IE 미지원) | 최대 (모든 브라우저) |
| 재연결 | 수동 구현 필요 | 자동 (EventSource) | 수동 구현 필요 |
| 프록시/LB | 설정 필요 | 불필요 | 불필요 |
| 예상 Latency | 낮음 (~10ms) | 낮음 (~10ms) | 중간 (~50ms) |
| 리소스 효율 | 높음 | 높음 | 낮음 |
| 운영 복잡도 | 높음 | 낮음 | 낮음 |

→ **현재 서비스 특성 고려 시 SSE가 유리해 보임** (단방향 푸시만 필요, 구현 단순, 자동 재연결)

#### 4-2. 연속 메시지 수신 지연 (Burst Latency) 테스트 ✅

**테스트**: 10명 구독자, 메시지 3개 연속 전송(50ms 간격), 200회 반복, 네트워크 지연 50ms

**테스트 코드**: `04-test/02-latency-message-realtime/`
- `test-latency-burst.js`: 메인 테스트 로직
- `run-test-burst.ps1`: 실행 스크립트
- `client-*.js`: WebSocket/SSE/Long Polling 클라이언트 구현

**결과** (단위: ms):

| Method | 성공/실패 | P50 | P95 | P99 | Max |
|--------|-----------|-----|-----|-----|-----|
| **WebSocket** | 200/0 | 346 | 375 | 381 | 381 |
| **SSE** | 200/0 | 355 | 377 | 380 | 380 |
| **Long Polling** | 198/2 | 356 | **32,735** | **32,741** | **32,741** |

**분석**:
- WebSocket/SSE: 연결 유지 → 모든 메시지 즉시 수신 (P99 ~380ms)
- Long Polling 문제:
  - 재연결 중 발송된 메시지는 **수신 불가** (메시지 유실)
  - 유실된 경우 **타임아웃(30초)까지 대기** → P95+ 폭증
  - P50: 356ms (정상), P95: 32,735ms (타임아웃)

**결론**: 
- **WebSocket/SSE**: 안정적이고 예측 가능 → 최종 후보
- **Long Polling**: 5%는 30초+ 지연, 메시지 유실 가능 → **제외** (Fallback으로만 고려)

#### 4-3. 동시 연결 부하 테스트

1. 점진적으로 연결 수 증가 (100 → 1,000 → 5,000 → 10,000)
2. 각 단계에서 메시지 전송 후 latency 측정
3. CPU/메모리 사용량 모니터링
4. 에러율 5% 넘는 지점 확인

#### 4-4. 장시간 연결 안정성 테스트

1. 1,000개 연결 유지
2. 30분간 1분마다 메시지 전송
3. 타임아웃, 연결 끊김 횟수 측정

