# 패치노트 - 실시간 통신 최적화 (기획)

## Before

- 메시지 도메인은 **REST API만** 제공 (POST/GET /messages)
- 클라이언트가 새 메시지를 받으려면 **폴링** 또는 **수동 새로고침** 필요
- 실시간 알림·수신 경험 부족, 메시지 서비스 핵심 가치인 **즉시 전달** 미달성
- WebSocket/SSE 등 실시간 채널에 대한 **기술 비교·선택·재연결·성능 측정** 계획 없음

## Goal

1. **실시간 메시지 수신**  
   - 발송 즉시 수신자에게 푸시 (폴링 제거)
2. **기술 선택 근거 마련**  
   - WebSocket vs SSE vs Long Polling 비교 후, 서비스 요구사항에 맞는 방식 선정
3. **연결 안정성**  
   - 연결 관리, 재연결 전략 설계 및 적용
4. **성능 정량화**  
   - latency, throughput 측정으로 목표치 설정 및 모니터링 기반 마련

## Key Decision

(비워둠)

## Impact

(비워둠)

---

## 진행 목표

1. WebSocket 구현 (POC: 연결, 구독/수신 — 송신은 POST /messages 유지)
2. SSE 구현 (POC)
3. Long Polling 구현 (POC)
4. 세 방식 비교
   - 4-1. 리소스: 연결당 CPU/메모리, 동시 연결 한계
   - 4-2. 성능: latency, throughput
   - 4-3. 운영·개발: 재연결, LB, 코드 복잡도
5. (비교 결과 반영) 1개 선정 → 프로덕션용 구현


## 진행

### 1. WebSocket 구현

- **의존성**: `spring-boot-starter-websocket` (STOMP 메시징용)
- **엔드포인트**: `/ws`, SockJS fallback 허용
- **인증**: Handshake 시 `Authorization` 또는 `access_token` 쿼리에서 JWT 검증 → `Principal`에 `userId` 넣기 (기존 `AuthTokenResolver` 재사용)
- **구독(수신)**: `/topic/chat-rooms/{chatRoomId}/messages` — 채팅방별 메시지 스트림 구독
- **송신**: WebSocket 제외. 기존 **POST /messages** 사용. 단, 생성 후 `SimpMessagingTemplate.convertAndSend(/topic/chat-rooms/{id}/messages, message)` 로 구독자에게 브로드캐스트 (MessageController 또는 ApplicationService에서)
- **POC 범위**: 연결·구독(수신)만 (재연결, Heartbeat 등은 4번 비교 이후)