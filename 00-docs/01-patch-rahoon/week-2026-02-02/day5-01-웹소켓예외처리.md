---
title: WebSocket 예외 처리 방안 고안
tags: [개인 프로젝트, WebSocket, 예외 처리]
date: 2026-02-06
---

## 프로젝트 요약

- **한 줄 요약**: WebSocket 연결·구독·메시지 처리 과정에서 발생하는 예외를 어떻게 처리할지 방안을 고안합니다.
- **키워드**: `WebSocket`, `예외 처리`, `STOMP`

## 문제(AS-IS)

- **REST API와 규약 불일치**: REST API는 예외 발생 시 정해진 응답 템플릿으로 내려주는 규약이 있으나, STOMP WebSocket에서는 예외 응답 형식이 정해져 있지 않음.
- **예외 파악·조치 어려움**: 클라이언트가 어떤 예외가 발생했는지 식별하기 어렵고, 그에 따른 조치(재시도·갱신·재연결 등)를 결정하기 어려움.
- **후속작업 미명시**: 예외에 따라 필요한 후속작업(연결 끊기, 인증 갱신 등)을 서버가 명시적으로 알려주지 않아, 클라이언트가 일관된 복구 흐름을 갖기 어려움.

## 목표(TO-BE)

- **일관된 응답 템플릿 제공**: STOMP WebSocket 예외도 REST API와 같이 정해진 응답 템플릿으로 내려주어, 클라이언트가 예외 유형·복구 방법을 파악할 수 있도록 함

## 설계/선택(Key decisions)

- **예외 응답 형식**: STOMP ERROR 프레임 body는 봉투(success/error) 없이 flat JSON. `code`, `message`, `details`, `occurredAt`, `receiptId`, `requestDestination`, `websocketSessionId` 등 필드로 고정 형식 제공.
- **예외 처리 범위**: DomainException(또는 cause 체인 내)은 해당 코드·메시지·details 사용. 그 외 예외는 `CommonError.SERVER_ERROR`로 동일 flat 형식 반환하여 클라이언트 파싱을 일원화.
- **성공 응답 형식**: `@WebsocketSend` / `@WebSocketReply` 전송 시 `{ payload, receiptId?, requestDestination?, websocketSessionId? }` 구조로 전송. 요청·세션·receipt 매칭에 활용.
- **문서 반영**: AsyncAPI 스펙 및 정적 웹 UI(websocket-docs)에 예외·성공 응답 형식 명시. 클라이언트 개발 시 참고 가능하도록 함.

## 결과(Impact)

- **예외 파악 용이**: 클라이언트가 `code`, `message`, `details`로 예외 유형·원인을 식별하고, 재시도·인증 갱신·재연결 등 조치를 결정하기 쉬워짐.
- **요청–응답 매칭**: `receiptId`, `requestDestination`으로 어떤 SEND에 대한 ERROR/Reply인지 추적 가능.
- **발생 시각**: `occurredAt`(ISO-8601)로 예외 발생 시각 기록·분석 가능.
- **문서 일원화**: 웹소켓 문서에 예외·성공 응답 형식이 반영되어, REST와 별도로 일관된 규약을 참고할 수 있음.
- **클라이언트 주의사항**: STOMP 스펙상 ERROR 수신 후 서버가 연결을 끊으므로, 클라이언트는 연결 종료 후 재연결·인증 갱신 등 정책을 구현해야 함.

---

## 구현 상세

**목차**
1. STOMP 프로토콜 정리
2. 응답 템플릿을 사용한 응답 제공
3. 웹소켓 문서에 응답 반영

---

### 1) STOMP 프로토콜 정리

**배경**: WebSocket 예외·응답 설계 전에 STOMP가 어떤 프레임을 쓰는지, 무엇을 내가 제어하고 무엇을 시스템이 제어하는지 정리. (STOMP 1.2 기준)

**STOMP란**  
클라이언트–서버 비동기 메시징용 텍스트 프로토콜. 프레임 = command + 헤더 + 빈 줄 + body(선택) + NULL octet.

**프레임 구조 예시**

```
SEND
destination:/topic/chat
content-type:application/json
receipt:req-1

{"text":"hello"}
^@
```

`^@` = NULL(0x00). 헤더 끝 = 빈 줄, body 끝 = NULL.

**내가 제어하는 command (클라이언트 → 서버)**  
애플리케이션이 **언제·무엇을** 보낼지 개발자가 결정.

| command | 역할 |
|---------|------|
| `CONNECT` / `STOMP` | 연결 시작 |
| `SEND` | 메시지를 `destination`으로 전송 (body = 전송 내용) |
| `SUBSCRIBE` | `destination` 구독 → 이후 `MESSAGE`로 수신 |
| `UNSUBSCRIBE` | 구독 해제 |
| `DISCONNECT` | 연결 종료 (선택: `receipt`로 수신 확인 요청) |
| `ACK` / `NACK` | 구독 ack 모드일 때 메시지 수신·처리 확인/거부 |
| `BEGIN` / `COMMIT` / `ABORT` | 트랜잭션 경계 |

**시스템이 제어하는 command (서버 → 클라이언트)**  
프로토콜/서버가 **규약에 따라** 보내는 응답. 개발자는 이 형식으로 오는 것만 해석하면 됨.

| command | 역할 |
|---------|------|
| `CONNECTED` | 연결 수락 (CONNECT에 대한 응답) |
| `MESSAGE` | 구독한 destination으로 도착한 메시지 전달 (body = 메시지 본문) |
| `RECEIPT` | `receipt` 넣어 보낸 프레임의 **수신 확인**. receipt-id로 요청 매칭. 비즈니스 "성공 응답 본문"이 아님. |
| `ERROR` | 오류 발생. 서버는 전송 후 **연결 종료**. body·message 헤더로 상세 전달. receipt 있으면 receipt-id로 매칭 권장. |

body 가능 프레임: **SEND**, **MESSAGE**, **ERROR**만.

**흐름 요약**  
CONNECT → CONNECTED or ERROR. 구독: SUBSCRIBE → 이후 MESSAGE로 수신. SEND → 서버가 destination으로 전달(구독자에게 MESSAGE 등). **SEND에 대한 "성공 응답 body"는 스펙에 없음.** 실패 시 ERROR. receipt 넣었으면 RECEIPT로 "받았고 처리했다"만 알림.
요청–응답이 필요하면 "SEND에 대한 성공 시 응답 본문"을 정의하지 않음. 요청–응답이 필요하면 **애플리케이션 규약**으로 (예: 임시 reply destination에 서버가 SEND한 결과를 MESSAGE로 보내기, 또는 payload에 requestId/correlationId 넣기) 구현하는 식.

**정리**

- **"성공 응답"**을 프로토콜 차원에서 정의하지 않음. SEND 성공 시 본문을 돌려주는 것은 서버·클라이언트가 정한 규약으로 채워야 함.

---

### 2) 응답 템플릿을 사용한 응답 제공

**목적**: STOMP WebSocket 예외·성공 응답 형식을 정하여, 클라이언트가 일관되게 파싱·처리할 수 있게 한다. 예외는 flat payload로, 성공은 정해진 구조로 제공한다.

**적용 범위**

- **예외 응답**: STOMP ERROR 프레임 payload → 아래 형식 참고.
- **성공 응답**: `@WebsocketSend` / `@WebSocketReply` 등으로 전송하는 메시지 payload → `{ "payload", "receiptId?", "requestDestination?", "websocketSessionId?" }` 형태.

**변경 대상**

| 구분 | 대상 클래스 | 변경 내용 |
|------|-------------|-----------|
| 예외 | `WebSocketExceptionStompSubProtocolErrorHandler`, `WebSocketExceptionBodyBuilder`, `WebSocketExceptionController` | ERROR 프레임 payload를 flat map으로 생성. `code`, `message`, `details`(DomainException.details), `occurredAt`(ZonedDateTime.now(), ISO-8601), `websocketSessionId`, `receiptId`, `requestDestination`(요청 시 STOMP destination) 포함. |
| 예외 (@MessageMapping) | `WebSocketMessageExceptionAdvice`, `WebSocketExceptionController.sendToExceptionQueue` | `@MessageMapping` 핸들러 내 예외 시 ERROR 프레임 대신 **exception 큐**로 동일 body 전송. destination: `/queue/session/{websocketSessionId}/exception`. 연결을 유지한 채 예외 수신 가능. |
| 성공 | `WebsocketSendAspect` | `@WebsocketSend` / `@WebSocketReply` 반환값을 `{ payload, receiptId?, requestDestination?, websocketSessionId? }` 형태로 감싼 뒤 전송. 클라이언트는 동일 구조로 수신. |

**예외 전달 경로 구분**

| 발생 시점 | 처리 주체 | 전달 방식 |
|-----------|-----------|-----------|
| STOMP 프로토콜·라우팅 단계 (clientInboundChannel.send() 이전) | `WebSocketExceptionStompSubProtocolErrorHandler` | **ERROR 프레임** 전송. 스펙상 전송 후 연결 종료. |
| @MessageMapping 핸들러 내부 | `WebSocketMessageExceptionAdvice` | **exception 큐** 전송 (`sendToExceptionQueue`). 동일 flat body를 MESSAGE로 `/queue/session/{websocketSessionId}/exception`에 전송. 기본 설정에서는 ERROR 프레임은 보내지 않음(연결 유지). |

- exception 큐를 구독해 두면, 핸들러에서 던진 예외를 ERROR 없이 MESSAGE로만 수신할 수 있음. receiptId·requestDestination으로 요청 매칭 가능.

**예외 응답 상세**

- 예외 응답은 아래와 같은 JSON으로 전달한다.

```json
{
  "code": "example_code",
  "details": {},
  "message": "example_message",
  "occurredAt": "2026-02-06T12:00:00+09:00",
  "receiptId": "example-id-123",
  "requestDestination": "example_requestDestination",
  "websocketSessionId": "example-id-123"
}
```

- `occurredAt`(예외 발생 시각, ISO-8601)는 구현에서 `ZonedDateTime.now()`로 포함 시 payload에 추가된다.
- `WebSocketExceptionBodyBuilder`에서 DomainException(또는 cause 체인 내 DomainException)으로 `WebSocketExceptionBody` 생성. `requestDestination`은 `WebSocketExceptionStompSubProtocolErrorHandler`에서 `StompHeaderAccessor.destination`으로 추출한다.
- DomainException이 아닌 예외는 `CommonError.SERVER_ERROR`로 body를 만들어 동일한 형식으로 반환한다.

**성공 응답 상세**

- `@WebsocketSend` / `@WebSocketReply`로 전송되는 메시지 body는 아래 구조를 사용한다.
- `payload`: 실제 응답 본문(도메인별 객체).
- `receiptId`, `requestDestination`, `websocketSessionId`: 있으면 포함(요청·세션 추적용).

---

### 3) 웹소켓 문서에 응답 반영

**목적**: 웹소켓 관련 문서에 예외·성공 응답 형식을 반영하여, 클라이언트 개발자가 응답 구조를 참고할 수 있게 한다.

**문서 위치**

| 구분 | 위치 | 설명 |
|------|------|------|
| AsyncAPI 스펙 | `GET /websocket-docs/api` | `WebSocketDocApiController`·`WebSocketDocGenerator`가 생성하는 AsyncAPI 3.0 JSON. SEND/RECEIVE 메시지 payload 스키마 포함. |
| 정적 웹 UI | `GET /websocket-docs/` (또는 `static/websocket-docs/`) | `index.html`, `app.js`, `styles.css`. 연결·구독·SEND 테스트용 UI. |

**반영할 내용**

- **예외 응답 (ERROR 프레임)**  
  - 문서(AsyncAPI 또는 별도 Conventions 섹션)에 ERROR 프레임 body 형식 명시:  
    `{ "code", "details", "message", "receiptId", "requestDestination", "websocketSessionId" }` (필드 있으면 포함, `occurredAt`는 구현에서 포함 시 추가).  
  - 예시: `{ "code": "example_code", "details": {}, "message": "example_message", "receiptId": "example-id-123", "requestDestination": "example_requestDestination", "websocketSessionId": "example-id-123" }`  
  - 후속작업: STOMP 스펙상 ERROR 수신 후 서버가 연결을 끊으므로, 클라이언트는 연결 종료 후 재연결·인증 갱신 등 정책에 따라 처리.

- **성공 응답 (MESSAGE 프레임, @WebsocketSend / @WebSocketReply)**  
  - `@WebsocketSend`·`@WebSocketReply`로 전송되는 메시지 body는 아래 구조를 사용함을 문서화:  
    `{ "payload": <실제 본문>, "receiptId?", "requestDestination?", "websocketSessionId?" }`  
  - 예시: `{ "payload": {}, "receiptId": "example-id-123", "requestDestination": "example_requestDestination", "websocketSessionId": "example-id-123" }`  
  - AsyncAPI에서 RECEIVE 메시지 payload 스키마를 이 구조로 정의하거나, 기존 도메인 스키마에 "payload 필드 안에 들어감"이라고 설명 추가.

- **구현 시 고려**  
  - `WebSocketDocGenerator`에 ERROR 응답용 스키마(flat) 및 성공 응답 스키마를 components에 넣거나,  
  - AsyncAPI `info.description` 또는 확장 필드에 "예외는 flat, 성공은 payload/receiptId/requestDestination/websocketSessionId 구조 사용" 문단을 추가하는 방식으로 반영 가능.
