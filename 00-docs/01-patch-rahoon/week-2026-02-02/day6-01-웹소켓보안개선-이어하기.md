---
title: WebSocket 보안 개선 (이어하기)
tags: [개인 프로젝트, WebSocket, 보안]
date: 2026-02-06
---

## 이어하기 요약

- **이전 문서**: [day3-01-웹소켓보안개선](../week-2026-01-26/day3-01-웹소켓보안개선.md) (To be continued 지점에서 이어서 진행)
- **한 줄 요약**: WebSocket 보안 개선의 남은 작업(갱신 API 규격, 구독 검증, 문서 반영 등)을 정리·구현합니다.
- **키워드**: `WebSocket`, `인증`, `인가`, `STOMP`, `갱신 API`

## 이전 문서에서 정리된 내용

- **1) 권한 기반 메시지 전달**: 유저별 전용 채널(`/topic/user/{uuid}/...`) 선택, 전송·구독 구조 설계 완료.  
  - ~~남은 작업: **구독 시 destination uuid = 토큰 uuid 검증** 추가.~~ ✅ **완료** (`WebSocketTopicSubscribeInterceptor`)
- **2) 인증 정보 전달**: STOMP CONNECT 시 헤더로 토큰 전달(B안) 선택. CONNECT·연결 유지 중 갱신·만료 처리 플로우 정리됨.  
  - ~~남은 작업: **갱신 API 규격**(헤더 이름, destination, 실패 시 처리) 정리 및 구현.~~ ✅ **완료** (`WebSocketAuthRefreshController`)
  - ~~남은 작업: **만료(임박) 시 처리** — 서버가 토큰 만료/만료 임박 감지 후 갱신 유도·유예 시간 후 미갱신 시 연결 종료 로직.~~ ✅ **완료** (만료 즉시 종료 + 만료 임박 시 갱신 유도 MESSAGE 전송)
- **3) 위 규칙에 따른 문서 개선**: ~~미진행.~~ ✅ **완료** (AsyncAPI info.description, websocket-docs 마크다운 렌더링, day6 갱신 API·테스트 절차)

---

## 이번 문서에서 진행할 작업

**목차**
1. ~~(선택) 갱신 API 규격 정리~~ ✅ **완료**
2. ~~(선택) 구독 권한 검증 — destination uuid = principal 검증~~ ✅ **완료**
3. ~~**만료(임박) 시 처리** — 만료 검증 + 만료 임박 갱신 유도~~ ✅ **완료**
4. ~~(선택) 위 규칙에 따른 문서 개선~~ ✅ **완료**
5. 설계/선택·결과 보완 (이전 문서에 역반영 또는 본 문서에 정리)

---

### 1) 갱신 API 규격 정리 ✅ **완료**

(구현: `WebSocketAuthRefreshController`, `WebSocketAuthRefreshBody`, `WebSocketAuthRefreshControllerIT`.)

- **Destination**: `/app/auth/refresh`
- **토큰 전달 방식**: 다음 둘 중 하나. 우선순위는 (1) > (2).
  1. **헤더**: `Authorization` (STOMP SEND 시 native header, 예: `Bearer {accessToken}`)
  2. **Body**: `accessToken` 필드 (JSON, 헤더가 없을 때 사용)
- **요청 Body 규격** (`WebSocketAuthRefreshBody`)

  | 필드 | 타입 | 필수 | 설명 |
  |------|------|------|------|
  | `accessToken` | string | X | 갱신할 액세스 토큰. 헤더로 전달 못 할 때 사용. |

- **성공 시**: 세션 `ATTR_AUTH_INFO` 갱신, 연결 유지. 별도 응답 프레임 없음.
- **실패 시**: `DomainException(CommonError.UNAUTHORIZED)` → `WebSocketExceptionStompSubProtocolErrorHandler`가 ERROR 프레임에 code·message 전달.

#### 갱신 API 수동 테스트 절차

1. **사전 준비**: 앱 실행 후 로그인 → `access_token`, `refresh_token` 획득.
2. **WebSocket 연결**: `ws://localhost:{port}/ws?access_token={access_token}`으로 SOCKJS 연결.
3. **auth 큐 구독**: CONNECTED 프레임의 `session` 헤더 값으로 `/queue/session/{sessionId}/auth` 구독.
4. **토큰 갱신**: REST `POST /auth/refresh`로 새 액세스 토큰 발급 후, 아래 중 하나로 SEND.
   - **방법 A (헤더)**: destination `/app/auth/refresh`, header `Authorization: Bearer {새토큰}`, body 빈 문자열.
   - **방법 B (Body)**: destination `/app/auth/refresh`, body `{"accessToken":"{새토큰}"}`.
5. **검증**: `token_expiring_soon` 수신 시 4번 반복. 갱신 후 기존 구독(`/topic/user/{userId}/messages` 등)으로 메시지 수신되는지 확인.

---

### 2) 구독 권한 검증 — destination uuid = principal ✅ **완료**

(구현: `WebSocketTopicSubscribeInterceptor`, `WebSocketConfig`에 등록)

- **목표**: `/topic/user/{uuid}/...` 구독 시 `uuid`가 현재 principal(토큰 사용자)와 일치하는지 검증.
- **구현 위치**: `WebSocketTopicSubscribeInterceptor` — `USER_TOPIC_PATTERN`으로 `/topic/user/{uuid}/...` 매칭 후 `principalUserId == topicUserId` 검증.
- **불일치 시**: `DomainException(CommonError.CLIENT_ERROR)` — payload에 `reason`, `expectedUserId` 포함. ERROR 프레임으로 전달.

---

### 3) 만료(임박) 시 처리

- **설계 원칙**: **만료**와 **만료 임박**을 구분해서 처리한다.
  - **만료**: 토큰(세션)이 이미 만료된 경우 → 서버가 감지 시 **즉시 ERROR 후 연결 종료**. 갱신 유도·유예 없음.
  - **만료 임박**: 만료 직전(임박)인 경우 → (추후) 갱신 유도 → 유예 시간 내 갱신 수신 시 연결 유지, 미갱신 시 종료.

#### 3-1) 만료 검증 ✅ **완료**

- **검사 방식**: **주기적 검사** — (1) 인바운드 메시지 수신 시, (2) **Heartbeat 주기**에서 세션 TTL 검사.
  - **(1) 인바운드**: CONNECT를 제외한 모든 STOMP 메시지(SEND, SUBSCRIBE, DISCONNECT 등) 수신 시 검사. `WebSocketSessionExpiryInterceptor`.
  - **(2) Heartbeat**: [WebSocketConfig]의 HEARTBEAT_INTERVAL_MS(10초)와 동일 주기로 스케줄러가 등록된 세션을 순회하며 만료 여부 검사. 만료 시 ERROR 전송 후 레지스트리에서 제거. `WebSocketSessionExpiryHeartbeatTask`, `WebSocketSessionAuthInfoRegistry`.
- **만료 기준**: 세션에 저장된 [CommonAuthInfo.expiresAt](JWT exp)이 현재 시각보다 이전이면 만료로 간주.
- **만료 시 처리**: [DomainException](CommonError.UNAUTHORIZED) 기반 **ERROR 프레임** 전송 후 연결 종료. 갱신 유도·유예 없이 즉시 종료.
- **구현**: `WebSocketSessionExpiryInterceptor`(인바운드) + `WebSocketSessionExpiryHeartbeatTask`(heartbeat 주기) + `WebSocketSessionAuthInfoRegistry`(CONNECT/Disconnect/auth/refresh 시 등록·해제).

#### 3-2) 만료 임박 처리 ✅ **완료**

- **목표**: 만료 직전(임박) 구간에서 갱신 유도 알림 전송. 실제 연결 종료는 JWT 만료 시 기존 3-1(만료 검증)대로 처리. 유예 시간·별도 상태 저장 없음.
- **구현**: `WebSocketAuthBody`, `WebSocketAuthController`, `WebSocketSessionExpiryHeartbeatTask` 확장, `WebSocketTopicSubscribeInterceptor`에 auth 패턴 추가, `WebSocketTokenExpiringSoonIT`.

**구현 내용**

1. **만료 임박 기준**
   - **정의**: `expiresAt`이 “현재 시각”보다 미래이면서, `현재 시각 + 임박 임계(threshold)` 이전인 경우를 “만료 임박”으로 본다.
   - **식**: `now < authInfo.expiresAt` 이고 `authInfo.expiresAt <= now + IMMINENT_THRESHOLD`.
   - **파라미터 예**: `IMMINENT_THRESHOLD` = 2분(또는 5분). 즉, 만료 2분 전부터 “임박”으로 간주.
   - **검사 시점**: **Heartbeat 주기**(`WebSocketSessionExpiryHeartbeatTask`)에서만 검사.  
     - 만료 검사(`expiresAt < now`)는 기존처럼 인바운드 + Heartbeat 둘 다 유지.  

2. **처리 흐름**
   - **임박 구간일 때**: Heartbeat 주기마다 해당 세션에 **갱신 유도** MESSAGE 전송. `/queue/session/{sessionId}/auth`로 전송.
   - **실제 종료**: JWT 만료(`expiresAt < now`) 시 기존 3-1과 동일하게 ERROR 후 연결 종료. 별도 유예 시간 없음.

   **갱신 유도 MESSAGE body 규격** (reply·exception과 유사한 정형 구조)
   | 필드 | 타입 | 필수 | 설명 |
   |------|------|------|------|
   | `event` | string | O | 이벤트 타입. 현재 값: `token_expiring_soon`. 향후 확장용. |
   | `expiresAt` | string | O | 토큰 만료 시각. ISO-8601 형식. |
   | `websocketSessionId` | string | O | 대상 세션 ID. reply·exception과 동일. 클라이언트 식별·매칭용. |
   | `occurredAt` | string | X | 서버 발송 시각. ISO-8601. (디버깅·로깅용) |

3. **구현 위치**
   - **Heartbeat 태스크** (`WebSocketSessionExpiryHeartbeatTask`):  
     (1) 기존: `expiresAt < now` → 즉시 ERROR 후 unregister.  
     (2) 추가: `now < expiresAt <= now + IMMINENT_THRESHOLD` 인 세션 → 갱신 유도 MESSAGE 전송(매 주기). 상태 저장·별도 레지스트리 없음.

4. **설정값**
   - `websocket.imminent-threshold-seconds`: 120 (기본 2분). 만료 이전 이 값 이내면 갱신 유도 MESSAGE 전송. `application.properties` 또는 환경변수 `WEBSOCKET_IMMINENT_THRESHOLD_SECONDS`.

5. **클라이언트 구독 참고**
   - `/queue/session/{sessionId}/auth` 구독 시 `sessionId`는 **CONNECTED 프레임의 `session` 헤더** 값을 사용해야 함.
   - `StompSession.getSessionId()`는 서버 session id와 다를 수 있음. `StompSessionHandler.afterConnected`에서 `connectedHeaders.getFirst("session")`으로 획득.

---

### 4) 위 규칙에 따른 문서 개선 ✅ **완료**

(구현: `WebSocketDocGenerator.buildInfoDescription`, websocket-docs `renderMarkdown`·`breaks: true`.)

- **AsyncAPI**: `info.description`에 인증 규칙, 구독 권한, 세션 큐 설명 반영.
- **websocket-docs**: description 마크다운 렌더링(marked.js), `breaks: true`로 줄바꿈 처리.
- **반영 내용**: 토픽 형식, 구독 권한 규칙, 갱신 API, 인증 방식 요약.

---

### 5) 설계/선택·결과 보완

- 이전 문서의 **설계/선택(Key decisions)**·**결과(Impact)**에 채울 내용을 여기서 정리한 뒤, 필요 시 해당 문서에 역기재.

---

## 결과(Impact)

### 구현 완료

- **갱신 API**: `/app/auth/refresh` — 헤더(`Authorization`) 또는 Body(`accessToken`)로 토큰 전달. `WebSocketAuthRefreshBody` DTO.
- **만료 임박 갱신 유도**: Heartbeat 주기마다 `expiresAt <= now + IMMINENT_THRESHOLD` 인 세션에 `/queue/session/{sessionId}/auth`로 `token_expiring_soon` MESSAGE 전송.
- **세션 큐 패턴 통일**: reply·exception에 이어 auth도 `/queue/session/{sessionId}/...` 형태로 통일, `WebSocketTopicSubscribeInterceptor`에서 구독 권한 검증.
- **설정**: `websocket.imminent-threshold-seconds`로 환경별 임박 임계 조정 가능.

### 클라이언트 개발 시 참고

- auth 큐 구독: CONNECTED 프레임의 `session` 헤더 값으로 `/queue/session/{sessionId}/auth` 구독.
- `token_expiring_soon` 수신 시: `/app/auth/refresh`로 새 토큰 SEND.
  - **헤더 방식**: `Authorization: Bearer {accessToken}` (body 불필요).
  - **Body 방식**: `{"accessToken":"{accessToken}"}` (헤더로 전달 어려울 때).
