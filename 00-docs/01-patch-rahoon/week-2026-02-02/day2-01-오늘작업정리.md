---
title: WebSocket 예외 처리 방안 고안
tags: [개인 프로젝트, WebSocket, 예외 처리]
date: 2026-02-03
---

## 프로젝트 요약

- **한 줄 요약**: WebSocket 연결·구독·메시지 처리 과정에서 발생하는 예외를 어떻게 처리할지 방안을 고안합니다.
- **키워드**: `WebSocket`, `예외 처리`, `STOMP`

## 문제(AS-IS)

- **REST API와 규약 불일치**: REST API는 예외 발생 시 정해진 응답 템플릿으로 내려주는 규약이 있으나, STOMP WebSocket에서는 예외 응답 형식이 정해져 있지 않음.
- **예외 파악·조치 어려움**: 클라이언트가 어떤 예외가 발생했는지 식별하기 어렵고, 그에 따른 조치(재시도·갱신·재연결 등)를 결정하기 어려움.
- **후속작업 미명시**: 예외에 따라 필요한 후속작업(연결 끊기, 인증 갱신 등)을 서버가 명시적으로 알려주지 않아, 클라이언트가 일관된 복구 흐름을 갖기 어려움.

## 목표(TO-BE)

- **일관된 응답 템플릿 제공**: STOMP WebSocket 예외도 REST API와 같이 정해진 응답 템플릿으로 내려주어, 클라이언트가 예외 유형·복구 방법을 파악할 수 있도록 함

## 설계/선택(Key decisions)

(구현 후 채울 예정)

## 결과(Impact)

(구현 후 채울 예정)

---

## 구현 상세

**목차**
1. STOMP 프로토콜 정리
2. 응답 템플릿을 사용한 응답 제공
3. 웹소켓 문서에 응답 반영

---

### 1) STOMP 프로토콜 정리

**배경**: WebSocket 예외·응답 설계 전에 STOMP가 어떤 프레임을 쓰는지, 무엇을 내가 제어하고 무엇을 시스템이 제어하는지 정리. (STOMP 1.2 기준)

**STOMP란**  
클라이언트–서버 비동기 메시징용 텍스트 프로토콜. 프레임 = command + 헤더 + 빈 줄 + body(선택) + NULL octet.

**프레임 구조 예시**

```
SEND
destination:/topic/chat
content-type:application/json
receipt:req-1

{"text":"hello"}
^@
```

`^@` = NULL(0x00). 헤더 끝 = 빈 줄, body 끝 = NULL.

**내가 제어하는 command (클라이언트 → 서버)**  
애플리케이션이 **언제·무엇을** 보낼지 개발자가 결정.

| command | 역할 |
|---------|------|
| `CONNECT` / `STOMP` | 연결 시작 |
| `SEND` | 메시지를 `destination`으로 전송 (body = 전송 내용) |
| `SUBSCRIBE` | `destination` 구독 → 이후 `MESSAGE`로 수신 |
| `UNSUBSCRIBE` | 구독 해제 |
| `DISCONNECT` | 연결 종료 (선택: `receipt`로 수신 확인 요청) |
| `ACK` / `NACK` | 구독 ack 모드일 때 메시지 수신·처리 확인/거부 |
| `BEGIN` / `COMMIT` / `ABORT` | 트랜잭션 경계 |

**시스템이 제어하는 command (서버 → 클라이언트)**  
프로토콜/서버가 **규약에 따라** 보내는 응답. 개발자는 이 형식으로 오는 것만 해석하면 됨.

| command | 역할 |
|---------|------|
| `CONNECTED` | 연결 수락 (CONNECT에 대한 응답) |
| `MESSAGE` | 구독한 destination으로 도착한 메시지 전달 (body = 메시지 본문) |
| `RECEIPT` | `receipt` 넣어 보낸 프레임의 **수신 확인**. receipt-id로 요청 매칭. 비즈니스 “성공 응답 본문”이 아님. |
| `ERROR` | 오류 발생. 서버는 전송 후 **연결 종료**. body·message 헤더로 상세 전달. receipt 있으면 receipt-id로 매칭 권장. |

body 가능 프레임: **SEND**, **MESSAGE**, **ERROR**만.

**흐름 요약**  
CONNECT → CONNECTED or ERROR. 구독: SUBSCRIBE → 이후 MESSAGE로 수신. SEND → 서버가 destination으로 전달(구독자에게 MESSAGE 등). **SEND에 대한 “성공 응답 body”는 스펙에 없음.** 실패 시 ERROR. receipt 넣었으면 RECEIPT로 “받았고 처리했다”만 알림.
요청–응답이 필요하면 “SEND에 대한 성공 시 응답 본문”을 정의하지 않음. 요청–응답이 필요하면 **애플리케이션 규약**으로 (예: 임시 reply destination에 서버가 SEND한 결과를 MESSAGE로 보내기, 또는 payload에 requestId/correlationId 넣기) 구현하는 식.

**정리**

- **“성공 응답”**을 프로토콜 차원에서 정의하지 않음. SEND 성공 시 본문을 돌려주는 것은 서버·클라이언트가 정한 규약으로 채워야 함.

---

### 2) 응답 템플릿을 사용한 응답 제공

**목적**: 1)에서 설계한 성공/예외 응답 템플릿을 STOMP WebSocket 실제 응답에 적용하여, 클라이언트가 `success` / `data` / `error` 봉투로 일관되게 파싱·처리할 수 있게 한다.

**적용 범위**

- **예외 응답**: STOMP ERROR 프레임 payload → `success: false`, `error: { code, message, details?, occurredAt?, destination? }`
- **성공 응답**: `@WebsocketSend` 등으로 브로드캐스트하는 메시지 payload → `success: true`, `data: 실제 본문`, `error: null`

**변경 대상**

| 구분 | 대상 클래스 | 변경 내용 |
|------|-------------|-----------|
| 예외 | `WebSocketStompErrorHandler` | ERROR 프레임 payload를 `{ success: false, error: ErrorInfo }` 형태로 생성. `error`에 `code`, `message`, `details`(DomainException.details), `occurredAt`(ZonedDateTime.now()), `destination`(clientMessage 헤더의 destination, 있으면) 포함. 기존 `{ code, message }`만 보내던 부분 제거. |
| 성공 | `WebsocketSendAspect` | `convertAndSend(topic, returnValue)` 시 `returnValue`를 그대로 보내지 말고, `CommonApiResponse.success(returnValue)`로 감싼 뒤 `convertAndSend(topic, response)` 호출. 클라이언트는 `success: true`, `data`, `error: null` 구조로 수신. |

**예외 응답 상세 (WebSocketStompErrorHandler)**

- `handleClientMessageProcessingError` 내부에서 DomainException 처리 시:
  - payload = `CommonApiResponse.error(...)`와 동일한 구조의 map. 단 REST의 `path` 대신 WebSocket 맥락으로 `destination` 사용.
  - `destination`: `clientMessage`가 있으면 `StompHeaderAccessor.wrap(clientMessage).destination`으로 요청 시 사용한 STOMP destination 추출해 `error.destination`에 넣음.
  - `occurredAt`: `ZonedDateTime.now()`를 ISO-8601 문자열로 직렬화.
- DomainException이 아닌 예외는 기존처럼 `super.handleClientMessageProcessingError(...)`에 위임(스택 트레이스 등 기본 동작 유지). 필요 시 추후 일반 예외도 동일 템플릿으로 감싸는 방안 검토.

**성공 응답 상세 (WebsocketSendAspect)**

- `broadcastReturnValue`에서 `returnValue != null`일 때:
  - `val response = CommonApiResponse.success(returnValue)`로 봉투 생성.
  - `messagingTemplate.convertAndSend(topic, response)`로 전송. `CommonApiResponse`는 이미 `success`, `data`, `error` 필드를 가지므로 JSON 직렬화 시 설계한 성공 템플릿과 동일한 형태로 나감.

**트레이드오프**

- **성공 응답 래핑**: 기존에는 `@WebsocketSend` 반환값(예: `MessageWsSend.Detail`)을 그대로 보냈다. 봉투를 적용하면 모든 구독 클라이언트가 `data` 안에서만 실제 본문을 꺼내 써야 하므로, 기존 클라이언트는 breaking change. 마이그레이션 시 클라이언트가 `response.data`를 사용하도록 변경 필요.
- **ErrorInfo와 destination**: REST용 `CommonApiResponse.ErrorInfo`는 `path`만 갖고 있음. WebSocket용 payload에서는 `destination`을 써야 하므로, Handler 내부에서는 `ErrorInfo`를 재사용하지 않고 map으로 `success`/`error`(code, message, details, occurredAt, destination)를 직접 구성하는 방식이 단순함. 공통 모델로 쓰려면 `ErrorInfo`에 `destination: String?` 필드를 추가하고 REST에서는 null로 두는 방법도 있음.

---

### 3) 웹소켓 문서에 응답 반영

**목적**: 웹소켓 관련 문서에 예외·성공 응답 형식을 반영하여, 클라이언트 개발자가 일관된 봉투 구조를 참고할 수 있게 한다.

**문서 위치**

| 구분 | 위치 | 설명 |
|------|------|------|
| AsyncAPI 스펙 | `GET /websocket-docs/api` | `WebSocketDocApiController`·`WebSocketDocGenerator`가 생성하는 AsyncAPI 3.0 JSON. SEND/RECEIVE 메시지 payload 스키마 포함. |
| 정적 웹 UI | `GET /websocket-docs/` (또는 `static/websocket-docs/`) | `index.html`, `app.js`, `styles.css`. 연결·구독·SEND 테스트용 UI. |

**반영할 내용**

- **예외 응답 (ERROR 프레임)**  
  - 문서(AsyncAPI 또는 별도 Conventions 섹션)에 ERROR 프레임 body 형식 명시:  
    `{ "success": false, "error": { "code", "message", "details?", "occurredAt?", "destination?" } }`  
  - `destination`: 해당 요청의 STOMP destination(있을 경우).  
  - 후속작업: STOMP 스펙상 ERROR 수신 후 서버가 연결을 끊으므로, 클라이언트는 연결 종료 후 재연결·인증 갱신 등 정책에 따라 처리.

- **성공 응답 (MESSAGE 프레임, @WebsocketSend)**  
  - `@WebsocketSend`로 브로드캐스트되는 메시지 body는 `CommonApiResponse` 봉투를 사용함을 문서화:  
    `{ "success": true, "data": <실제 본문>, "error": null }`  
  - AsyncAPI에서 RECEIVE 메시지 payload 스키마를 봉투 구조( success, data, error )로 정의하거나, 기존 도메인 스키마에 “data 필드 안에 들어감”이라고 설명 추가.

- **구현 시 고려**  
  - `WebSocketDocGenerator`에 ERROR 응답용 스키마(예: `WebSocketErrorPayload`)를 components에 넣거나,  
  - AsyncAPI `info.description` 또는 확장 필드에 “예외/성공 응답은 공통 봉투 사용” 문단을 추가하는 방식으로 반영 가능.
