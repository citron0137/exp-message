---
title: 구조화된 로깅 전략 설계
tags: [개인 프로젝트, 로깅, 구조화 로깅, MDC, 분산 추적]
date: 2026-02-14
---

## 프로젝트 요약

- **한 줄 요약**: SLF4J 기반 평문 로깅에서 JSON 구조화 로깅으로 전환하여 디버깅·모니터링·분산 추적을 개선하기 위한 전략 수립
- **키워드**: `JSON 로깅`, `MDC`, `logstash-logback-encoder`, `분산 추적`, `로그 마스킹`, `Loki`

## 문제(AS-IS)

- SLF4J만 사용 중이며, 로그가 평문(plain text) 형식으로 출력됨
- 로그 레벨/구조화 전략이 없어 디버깅·모니터링 시 파싱·검색이 어려움
- 요청 단위 추적(traceId, spanId)이 없어 분산 환경에서 요청 흐름 추적 불가
- 민감 정보(비밀번호, 토큰 등) 로그 노출 위험에 대한 대응 전략 부재
- 로그 수집/중앙화 파이프라인(Loki 계획은 있으나) 미구현

## 목표(TO-BE)

1. JSON 형식의 구조화 로깅으로 로그 파싱·검색 용이성 확보
2. 환경별(dev/staging/prod) 로그 레벨·출력 형식 전략 수립
3. 로그 필드 표준화(timestamp, level, message, traceId, spanId 등)
4. MDC 기반 traceId/spanId로 분산 추적 가능하게 구성
5. 민감 정보 마스킹 규칙 수립
6. 로그 수집 스택 선택 및 연동 방향 결정
7. HTTP Request 컨텍스트 로깅(method, path, status, duration 등)
8. User/Client 컨텍스트 로깅(user_id, client_ip, user_agent 등)
9. WebSocket 컨텍스트 로깅(websocket_command, websocket_session_id, websocket_destination 등)

## 설계/선택(Key decisions)

(구현 후 채울 예정)

## 결과(Impact)

(구현 후 채울 예정)

---

## 구현 상세

### 1) JSON 형식의 구조화 로깅으로 로그 파싱·검색 용이성 확보

**배경**: 현재 Spring Boot 기본 Logback으로 평문 로그가 출력됨. 로그 수집(Loki 등)과 연동하려면 파싱 가능한 형식이 필요함. 목적은 로깅 인프라에서 파싱·검색·트레이스 연동을 쉽게 하는 것.

- **(후보1) stdout JSON (Logback 내장 JsonEncoder)**
  - (장점1) 추가 의존성 없음
  - (장점2) 구현 단순
  - (장점3) `kubectl logs`로 바로 확인 가능
  - (장점4) Promtail/Filebeat와 자연스럽게 연동
  - (단점1) 필드 on/off 위주, 커스터마이징 제한적
  - (단점2) trace_id는 MDC 별도 주입 필요
- **(후보2) stdout JSON (logstash-logback-encoder)**
  - (장점1) 후보 1의 장점 3, 4 포함
  - (장점2) 필드명·패턴·마스킹 등 커스터마이징 풍부
  - (장점3) ELK/Loki 연동 최적화
  - (단점1) 추가 의존성 필요
  - (단점2) trace_id는 MDC 별도 주입 필요
- **(후보3) OTel OTLP (OpenTelemetryAppender)**
  - (장점1) 앱에서 JSON 불필요
  - (장점2) trace_id 자동 부착
  - (장점3) 로그·트레이스·메트릭 통합
  - (단점1) Collector 필수, 설정 복잡
  - (단점2) 로그 처리 시 Collector 부하 큼(후보 1·2 대비)
    - Collector가 없는 경우(후보 1·2): 앱 → stdout → Promtail/Filebeat가 pull → Loki. Collector 경유 없음.
    - Collector가 있는 경우(후보 3): 앱 → OTLP push → Collector 수신·파싱·전달 → Loki. Collector가 로그 처리량 병목(항목당 비용 커서 동일 리소스에서 수~십 건/sec 수준).
  - (단점3) stdout에 로그 없어 디버깅 어려움

**결정**: stdout JSON (logstash-logback-encoder)
- 필드명·패턴·마스킹 등 커스터마이징 풍부
- 목표 5번(민감 정보 마스킹)에 적합
- Collector 경유 없어 로그 처리 성능 우수(후보 3 대비)
- trace_id는 목표 4번(MDC)에서 별도 처리

**적용 완료**: `build.gradle.kts` 의존성 추가, `logback-spring.xml` 생성

### 2) 환경별(dev/staging/prod) 로그 레벨·출력 형식 전략 수립

**적용 완료**: `LOGGING_FORMAT` 환경변수로 출력 형식 지정(json/plain). `application.properties`의 `logging.format=${LOGGING_FORMAT:json}`, `default.env`에 항목 추가.

### 3) MDC 기반 traceId/spanId로 분산 추적 가능하게 구성

**목적**: 요청 단위로 로그를 묶어 추적 가능하게 함. Loki 등에서 `trace_id`로 검색 시 동일 요청의 모든 로그를 한 번에 조회.

**처리 방안 후보**:
- **(후보1) 수동 MDC (Filter)**
  - (장점1) 추가 의존성 없음
  - (장점2) 구현 단순, Filter에서 UUID 생성 후 MDC.put/clear
  - (단점1) spanId는 단일 요청이라 생략 가능, 분산 추적 시 수동 전파 필요
- **(후보2) OTel Java Agent**
  - (장점1) trace_id/span_id 자동 주입, 코드 변경 없음
  - (장점2) W3C Trace Context 표준 준수
  - (단점1) Agent JAR 추가, `-javaagent` 실행 방식 변경 필요
- **(후보3) Micrometer Tracing**
  - (장점1) trace_id/span_id 자동 주입, Spring Boot 3.x 네이티브
  - (장점2) W3C Trace Context 표준 준수
  - (장점3) Zipkin/Tempo 연동 시 유리
  - (단점1) Brave 등 의존성 추가

**결정**: Micrometer Tracing (후보3)
- trace_id/span_id 자동 주입, W3C 표준 준수
- 의존성 1개·설정 1줄·코드 0줄로 도입 부담 낮음
- 향후 Zipkin/Tempo 연동 시 즉시 활용 가능

**적용 완료**: `build.gradle.kts`에 `micrometer-tracing-bridge-brave` 추가, `application.properties`에 tracing 설정, `logback-spring.xml`의 LogstashEncoder가 MDC(traceId/spanId)를 JSON에 포함

### 4) MDC(traceId/spanId) 전파 추가 설정

**목적**: 비동기나 Websocket등 에서도 trace_id로 추적 가능하게 함.

**기술적 배경**:
- 동일 요청에서 파생된 작업은 traceId 유지(parent-child)가 표준(W3C Trace Context)
  - 다만, 메시지 큐 consumer처럼 시간·서비스가 분리되면 span link로 별도 trace를 연결
- MDC는 ThreadLocal 기반이라 스레드가 바뀌면 traceId/spanId가 사라짐
- 따라서 아래와 같은 상황에서 context가 끊김: 
  - 비동기 프로세스: @Async, Executor, CompletableFuture.supplyAsync(), AsyncRunner.runAsync/supplyAsync
  - Kotlin 코루틴 (추후 도입시)
  - WebSocket 메시지(clientInboundChannel)
  - @Scheduled, ThreadPoolTaskScheduler(WebSocket heartbeat·세션 만료 등, 요청 context 없음)
  - Redisson topic listener(외부 라이브러리 스레드)


**처리1: 비동기 프로세스**
- AsyncConfig.taskExecutor에 ContextPropagatingTaskDecorator 적용
- @Async, AsyncRunner.runAsync/supplyAsync에서 traceId/spanId 전파

**처리2: WebSocket 메시지(clientInboundChannel)**
- clientInboundChannel용 ChannelInterceptor 추가(가장 먼저 등록)
- preSend에서 Tracer로 span 생성·MDC 설정, afterSendCompletion에서 MDC clear
- 적용 완료: WebSocketTracingChannelInterceptor 생성, WebSocketConfig에 첫 번째 인터셉터로 등록

**처리3: @Scheduled, ThreadPoolTaskScheduler**
- SpanRunner: trace context 없는 실행에서 `runWithSpan(name) { ... }` / `supplyWithSpan(name) { ... }`로 span 생성·MDC 설정·정리
- ScheduledSpanAspect: @Scheduled 메서드에 span 자동 적용
- TaskScheduler 분리: AsyncConfig에 taskScheduler(primary, @Scheduled용) · WebSocketTaskSchedulerConfig에 webSocketBrokerTaskScheduler(SimpleBroker heartbeat)
- WebSocketSessionExpiryHeartbeatTask: @Scheduled로 전환, 필요 시 @Async로 taskExecutor에서 실행

**처리4: Redisson topic listener** ✅
- Redisson addListener 콜백은 Redisson 내부 스레드에서 실행되어 trace context 없음
- 적용: AsyncRunner.runAsync로 콜백 본문을 비동기 실행 → Redisson 스레드 즉시 반환, taskExecutor에서 SpanRunner.runWithSpan + publishEvent 처리
- (추후) MessageCommandEvent에 traceparent 포함 시 publisher→subscriber trace 연속 가능

### 5) 민감 정보 마스킹 규칙 수립

**목적**: 로그에 비밀번호, 토큰, 시크릿 등 민감 정보가 노출되지 않도록 마스킹 규칙을 적용함.

**기술적 배경**:
- logstash-logback-encoder 7.0+는 `MaskingJsonGeneratorDecorator`로 JSON 출력 시점에 마스킹 지원
- 마스킹 방식: (1) 필드 기반(FieldMasker) – JSON 필드명/경로로 전체 값 마스킹, (2) 값 기반(ValueMasker) – 정규식으로 값 내 패턴 마스킹

**처리 방안 후보**:
- **(후보1) 필드 기반 마스킹(PathMask / FieldNameBasedFieldMasker)**
  - (장점1) 추가 의존성 없음, logstash-logback-encoder 내장
  - (장점2) 필드명만 지정하면 전체 값 마스킹, 성능 우수
  - (단점1) MDC·structured argument 등 JSON 필드에만 적용
  - (단점2) message 필드 내 `password=xxx` 같은 부분 문자열은 마스킹 불가
- **(후보2) 값 기반 마스킹(RegexValueMasker)**
  - (장점1) message 등 필드 값 내 패턴 마스킹 가능
  - (단점1) 정규식 매칭 비용, 로그량 많을 때 성능 영향
  - (단점2) 패턴 설계·유지보수 부담
- **(후보3) 서드파티(logstash-logback-sensitive-data-obfuscator 등)**
  - (장점1) 사전 정의된 패턴 제공
  - (단점1) 추가 의존성, 프로젝트 요구에 맞지 않을 수 있음

**결정**: 필드 기반 마스킹(후보1) 우선 적용
- MDC·structured argument에 들어가는 민감 필드(password, token, authorization 등)를 필드명으로 마스킹
- message 내부 패턴 마스킹은 필요 시 RegexValueMasker로 추후 확장

**마스킹 대상 필드(예시)**:
- `password`, `secret`, `token`, `accessToken`, `refreshToken`
- `authorization`, `cookie`, `apiKey`, `api_key`
- (선택) `db_password`, `redis_password` – 설정 로깅 시

**구현 방식**:
- `logback-spring.xml`의 LogstashEncoder에 `jsonGeneratorDecorator`로 `MaskingJsonGeneratorDecorator` 추가
- `addPath()` 또는 `addPaths()`로 마스킹할 필드명 지정
- 기본 마스크값: `****` (변경 가능)

**적용 완료**: `logback-spring.xml`의 LogstashEncoder에 `jsonGeneratorDecorator`로 `MaskingJsonGeneratorDecorator` 추가. 마스킹 대상: password, secret, token, accessToken, refreshToken, authorization, cookie, apiKey, api_key

### 7) HTTP Request 컨텍스트 로깅(method, path, status, duration 등)

**목적**: HTTP 요청 처리 시 로그에 method, path, status, duration을 포함하여 Loki 등에서 필터·집계 가능하게 함.

**처리 방안 후보**:

- **(후보1) OncePerRequestFilter (커스텀)**
  - (장점1) 요청 진입 시점에 MDC 설정, 응답 완료 후 정리
  - (장점2) ContentCachingResponseWrapper로 status 확보
  - (장점3) 모든 HTTP 요청에 적용, WebSocket handshake 등에도 적용
  - (단점1) 요청 처리 중 로그에는 method, path만 포함(status/duration은 완료 시점에만 알 수 있음)
  - (단점2) 커스텀 코드 유지보수 부담

- **(후보2) Logback MDCInsertingServletFilter**
  - (장점1) Logback 내장, 추가 의존성 없음
  - (장점2) method, requestURI, userAgent, xForwardedFor, remoteHost 등 제공
  - (단점1) **status, duration 미제공** → 별도 보완 필요
  - (단점2) MDC 키가 `req.method`, `req.requestURI` 등 Logback 규약 사용

- **(후보3) MDCInsertingServletFilter + status/duration 보완 필터**
  - (장점1) Logback 표준 활용, user-agent 등 추가 정보 확보
  - (장점2) 보완 필터는 status·duration만 담당해 코드 단순
  - (단점1) 필터 2개 조합, MDC 키가 `req.*`와 `http.*` 혼재 가능

- **(후보4) Micrometer Observation (ObservationHandler)**
  - (장점1) 메트릭·트레이스와 동일한 Observation 기반, 아키텍처 일관성
  - (장점2) 커스텀 Filter 불필요, Handler만 등록
  - (장점3) traceId/spanId와 같은 컨텍스트에서 동작
  - (단점1) duration은 Handler에서 직접 계산(ThreadLocal 등) 필요
  - (단점2) status/duration은 onStop 시점에만 MDC 설정 가능

- **(후보5) HandlerInterceptor**
  - (장점1) preHandle/postHandle/afterCompletion로 세밀한 제어
  - (단점1) WebSocket 등 DispatcherServlet 경유하지 않는 요청에는 미적용
  - (단점2) Filter 대비 적용 범위 제한적

**결정**: Micrometer Observation(후보4)
- Spring Boot 3 관찰성 모델과 일치, traceId/spanId와 동일한 Observation 기반
- `ObservationHandler<ServerRequestObservationContext>` 구현, `@Component`로 자동 등록
- onScopeOpened에서 method, path MDC 설정 → 처리 중 모든 로그에 포함
- onScopeClosed에서 status, duration MDC 설정 후 `log.debug("Request completed: ...")` 출력, MDC 정리
- duration은 ThreadLocal로 측정

**MDC 필드명**: `http.method`, `http.path`, `http.status_code`, `http.duration_ms`

**적용 완료**: `HttpRequestObservationHandler` 생성(common/observation), Spring Boot가 ObservationHandler 빈을 ObservationRegistry에 자동 등록

### 8) User/Client 컨텍스트 로깅(user_id, client_ip, user_agent 등)

**목적**: 로그에 사용자·클라이언트 식별 정보를 포함하여 감사·디버깅·보안 분석에 활용.

**처리 방안 후보**:

- **(후보1) HttpRequestObservationHandler 확장 + CommonAuthInfoArgumentResolver**
  - (장점1) 7번과 동일한 Handler에서 처리, 아키텍처 일관성
  - (장점2) client_ip, user_agent는 request에서 즉시 추출, Handler에 추가
  - (장점3) user_id는 ArgumentResolver에서 토큰 검증 시점에 MDC.put → 토큰 검증 로직 중복 없음
  - (단점1) user_id는 컨트롤러 진입 시점부터만 MDC에 존재(요청 초기 로그에는 없을 수 있음)

- **(후보2) AuthContextFilter + Handler 확장**
  - (장점1) onScopeOpened 시점에 user_id까지 모두 MDC 설정 가능
  - (단점1) 토큰 검증 로직 중복(ArgumentResolver와), Filter 추가

- **(후보3) HandlerInterceptor에서 user_id만 보완**
  - (단점1) Interceptor는 ServerHttpObservationFilter보다 늦게 실행. onScopeOpened 시점에 아직 미실행

**결정**: HttpRequestObservationHandler 확장 + CommonAuthInfoArgumentResolver(후보1)

**선택 이유**:
- **client_ip, user_agent → Handler**: 요청 진입 시점(onScopeOpened)에 request에서 즉시 추출 가능. 별도 Filter나 토큰 검증 없이 설정 가능.
- **user_id, auth_session_id → ArgumentResolver**: JWT 검증 후에만 알 수 있음. ArgumentResolver가 이미 토큰 검증을 수행하므로 여기서 MDC 설정 시 검증 로직 중복 없음. AuthContextFilter(후보2)는 별도 Filter에서 토큰 검증 → 중복.
- **MDC 정리 → Handler**: 요청 수명 주기를 Handler가 관리하므로 onScopeClosed에서 한 곳에서 정리. Resolver가 넣은 user_id, auth_session_id도 Handler가 제거하여 누락·잔류 방지.

**구현 방식**:
- client_ip, user_agent: Handler의 onScopeOpened에서 request에서 추출. client_ip는 X-Forwarded-For 우선, 없으면 remoteAddr
- user_id, auth_session_id: CommonAuthInfoArgumentResolver.resolveArgument에서 authInfo 반환 시 MDC.put(MdcKeys.USER_ID, ...), MDC.put(MdcKeys.AUTH_SESSION_ID, ...)
- MDC 정리: Handler의 onScopeClosed에서 user_id, auth_session_id 포함 모든 키 제거

**MDC 필드명**: `user_id`, `auth_session_id`, `client_ip`, `user_agent`

**적용 완료**: HttpRequestObservationHandler에 client_ip, user_agent 추가. CommonAuthInfoArgumentResolver에 user_id, auth_session_id(JWT sid) MDC 설정 추가

### 9) WebSocket 컨텍스트 로깅(websocket_command, websocket_session_id, websocket_destination 등)

**목적**: WebSocket 메시지 처리 시 로그에 websocket_command, websocket_session_id, websocket_destination, websocket_start_time, websocket_end_time, websocket_duration_ms, user_id, auth_session_id를 포함하여 Loki 등에서 필터·집계·추적 가능하게 함.

**기술적 배경**:
- WebSocket 메시지는 clientInboundChannel을 통해 처리되며, HTTP 요청 context가 없음
- 4번 처리2에서 WebSocketTracingChannelInterceptor가 traceId/spanId를 preSend에서 설정, afterSendCompletion에서 정리
- StompHeaderAccessor로 command, sessionId, destination(websocket_destination), sessionAttributes(CommonAuthInfo) 추출 가능

**처리 방안 후보**:

- **(후보1) WebSocketTracingChannelInterceptor 확장**
  - (장점1) 이미 모든 메시지에 preSend/afterSendCompletion 실행, traceId/spanId와 동일한 생명 주기
  - (장점2) StompHeaderAccessor로 command, sessionId, destination, sessionAttributes 추출 가능 (command → websocket_command, destination → websocket_destination으로 MDC에 저장)
  - (장점3) 별도 Interceptor 불필요, 아키텍처 일관성
  - (단점1) Interceptor 책임이 trace+MDC로 늘어남

- **(후보2) 별도 WebSocketMdcChannelInterceptor 추가**
  - (장점1) 목적 분리(trace vs MDC)
  - (단점1) Interceptor 2개, 순서 관리 필요. WebSocketTracingChannelInterceptor보다 먼저 실행해야 MDC가 trace와 함께 유지됨
  - (단점2) preSend/afterSendCompletion 중복 호출

- **(후보3) WebSocketConnectInterceptor에서만 MDC 설정**
  - (단점1) CONNECT 시점에만 적용. SUBSCRIBE, SEND 등 이후 메시지에는 미적용
  - (단점2) 메시지별 websocket_destination 로깅 불가

**결정**: WebSocketTracingChannelInterceptor 확장(후보1)

**선택 이유**:
- traceId/spanId와 동일한 메시지 단위 생명 주기로 MDC 설정·정리 → 스레드 재사용 시 잔류 방지
- 모든 STOMP 메시지(CONNECT, SUBSCRIBE, SEND 등)에 적용
- websocket_destination은 SUBSCRIBE/SEND에만 존재, CONNECT에는 null → null이면 미설정

**구현 방식**:
- preSend: StompHeaderAccessor.wrap(message)로 accessor 획득
  - websocket_command: accessor.command?.name (CONNECT, SUBSCRIBE, SEND 등)
  - websocket_session_id: accessor.sessionId
  - websocket_destination: accessor.destination (SUBSCRIBE, SEND 시에만 존재. CONNECT에는 null)
  - websocket_start_time: preSend 시점 OffsetDateTime.now()
  - user_id, auth_session_id: accessor.sessionAttributes?.get(WebSocketAuthHandshakeHandler.ATTR_AUTH_INFO) as? CommonAuthInfo. CONNECT 메시지에는 WebSocketConnectInterceptor가 아직 실행 전이므로 없음. SUBSCRIBE, SEND 등 이후 메시지부터 존재.
- afterSendCompletion: duration 계산(ThreadLocal nanoTime), websocket_end_time, websocket_duration_ms MDC 설정 후 로그 출력, 모든 키 제거
- MdcKeys에 WEBSOCKET_COMMAND, WEBSOCKET_SESSION_ID, WEBSOCKET_DESTINATION, WEBSOCKET_START_TIME, WEBSOCKET_END_TIME, WEBSOCKET_DURATION_MS 추가

**MDC 필드명**: `websocket_command`, `websocket_session_id`, `websocket_destination`, `websocket_start_time`, `websocket_end_time`, `websocket_duration_ms`, `user_id`, `auth_session_id`

**적용 완료**: WebSocketTracingChannelInterceptor 확장, MdcKeys에 WEBSOCKET_COMMAND, WEBSOCKET_SESSION_ID, WEBSOCKET_DESTINATION, WEBSOCKET_START_TIME, WEBSOCKET_END_TIME, WEBSOCKET_DURATION_MS 추가