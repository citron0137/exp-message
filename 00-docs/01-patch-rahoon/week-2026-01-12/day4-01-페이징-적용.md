# 패치노트 - 2026-01-15

## 문제 상황 / 결정 사항

### 1) 전체 조회로 인한 성능 리스크

- **문제 상황**: 목록 조회가 전체 조회(List 반환)라 데이터가 커지면 DB/메모리/네트워크 비용이 급증
- **결정 사항**: 목록 조회는 **커서 기반 페이징을 기본/표준**으로 적용 (Offset 기반은 원칙적으로 미지원)

### 2) cursor/limit의 Optional 처리

- **문제 상황**: 첫 페이지는 커서가 없고, limit을 매번 보내기 귀찮거나(클라이언트) 서버가 기본값을 가져야 함
- **결정 사항**:
  - `cursor`: Optional (미지정 시 첫 페이지)
  - `limit`: Optional (미지정 시 기본값 적용)

### 3) cursor 타입과 내부 포맷

- **문제 상황**: cursor를 숫자/id로 노출하면 정렬 기준 변경/확장에 취약하고, 형식도 API마다 달라질 수 있음
- **결정 사항**:
  - 요청/응답 `cursor`는 항상 `String`
  - 내부 포맷은 **queryParam payload → Base64URL 인코딩**
    - payload 공통 필드: `v`(버전), `sk`(정렬 기준 이름), `id`(마지막 데이터 id), `{sk}`(정렬 기준 값)
    - 예시(payload): `v=1&sk=createdAt&id=12345&createdAt=1736900000123`
    - 예시(cursor): `base64url(payload)` (URL-safe, 필요 시 padding 제거)

### 4) limit 처리 규칙(기본값/최대값)

- **문제 상황**: limit을 무한정 허용하면 DoS/비용 문제가 생김
- **결정 사항**:
  - 기본 limit: 20 (미지정 시)
  - 최대 limit: 100
  - 최대 초과 시 clamp

### 5) 응답에 페이징 정보를 어디에 담을지(호환성)

- **문제 상황**: 현재 목록 응답의 `data`가 `List`(배열)이라 `{items,nextCursor,...}`로 바꾸면 규약이 깨질 수 있음
- **결정 사항**: **기존 body 구조(`ApiResponse`)는 유지**하고, 페이징 메타는 `meta`에 담는 방향
  - (근거) JSON:API에서도 컬렉션 응답의 `data`는 배열로 두고, 페이징/부가 메타는 `links`/`meta`로 분리하는 패턴을 권장하며 X API, Stripe, Facebook Graph API 등에서도 유사 구조를 사용함
  - (왜 새 API를 만들지 않았나): v2/new endpoint로 분리하면 **클라이언트/문서/운영(라우팅·테스트) 비용이 증가**하고, 기존 API와의 **중복 유지보수**가 생김. 이번 변경은 “목록 응답(data)은 그대로 두고 메타만 추가”로 **호환성 리스크를 최소화**할 수 있어 우선 이 방식으로 진행.
  - `data`: 기존과 동일하게 리스트(배열)
  - `meta.nextCursor`: 다음 페이지 커서 (`null`이면 마지막 페이지)
  - `meta.limit`: 실제 적용된 limit (기본값/최대값 clamp 결과)

### 6) 적용 우선순위

- **문제 상황**: 한 번에 전 API를 바꾸면 영향 범위가 커짐
- **결정 사항**: 아래 순서로 단계 적용
  - ChatRoom → Member → Message → ChatRoom(`lastMessageAt` 추가 후 정렬 기준 적용)

## 테스트 계획

- [ ] 단위 테스트: 커서 페이징 경계값(첫 페이지/마지막 페이지/빈 결과)
- [ ] 통합 테스트: `nextCursor`로 페이지가 끊김 없이 이어지는지 검증
- [ ] 성능 확인: “전체 조회” 대비 DB 부하/응답 크기 감소 확인

## 추후 해볼 것

- cursor 변조 방지: payload에 `sig`(HMAC 등) 추가 및 서버 검증
- (Message) “이전/이후 페이지” 모두 지원이 필요하면 양방향 커서 전략 검토
- 메트릭 추가: API별 결과 건수, limit 분포, nextCursor 반환 비율, 느린 쿼리 감지

## 최종 정리(현재 합의된 스펙)

- **페이징 방식**: 커서 기반(표준), Offset 기반 미지원
- **Request**
  - `cursor`: Optional String (미지정 시 첫 페이지)
  - `limit`: Optional (미지정 시 20, 최대 100, 초과 시 clamp)
- **Response**
  - `data`: 기존과 동일한 리스트(배열)
  - `meta.nextCursor`: String? (`null`이면 마지막 페이지)
  - `meta.limit`: Int (실제 적용된 limit)
- **cursor 포맷(내부)**
  - queryParam payload → Base64URL 인코딩
  - payload: `v`, `sk`, `id`, `{sk}`
- **우선순위**: ChatRoom → Member → Message → ChatRoom(`lastMessageAt`)

